[gd_scene load_steps=5 format=1]

[ext_resource path="res://level/TileSet.tres" type="TileSet" id=1]
[ext_resource path="res://assets/Exit1.png" type="Texture" id=2]

[sub_resource type="GDScript" id=1]

script/source = "extends TileMap

export(int) var distance = 15
export(int) var width = 40
export(int) var height = 30
export(int) var tilesize = 32
export(int) var pathes = 5 #pathes without obstacles
export(int) var wall_x = 25 #walls oriated parallel to x-axis
export(int) var wall_y = 33 #walls oriated parallel to y-axis
export(int) var wall_x_max_len = 13
export(int) var wall_y_max_len = 10
export(int) var start

signal ready

func _ready():
	# Called every time the node is added to the scene.
	# Initialization here
	
	# random Start and Exit points at least distance tiles away from each other
	randomize() #new randomseed
	
	var map = {}
	# init map with all tiles 0
	for i in range(width):
		map[i] = {}
		map[i][0] = 1
		map[i][height-1] = 1

	for j in range(height):
		map[0][j] = 1
		map[width-1][j] = 1
	
	for i in range(width-2):
		for j in range(height-2):
			map[i+1][j+1] = 0
	
	
	
	
	# place $(wall_x) walls parallel to x-axis
	var walls = []
	for i in range(wall_x):
		#random y position of wall
		var temp = randi()%(height-walls.size())
		while(walls.has(temp)):
			temp += 1
		walls.append(temp)
		
		var len = randi()%wall_x_max_len #random lenght of wall
		var offset = randi()%(width-len) #space between side and wall
		for j in range(len):
			map[j+offset][temp] = 1

	# place $(wall_y) walls parallel to y-axis
	walls = []
	for i in range(wall_y):
		#random x position of wall
		var temp = randi()%(width-walls.size())
		while(walls.has(temp)):
			temp += 1
		walls.append(temp)
		
		var len = randi()%wall_y_max_len #random lenght of wall
		var offset = randi()%(height-len) # space between top and wall
		for j in range(len):
			map[temp][j+offset] = 1
	
	
	
	
	# start
	var start_x = (randi()%(width-2))+1
	var start_y = (randi()%(height-2))+1
	
	start = Vector2(start_x*tilesize,start_y*tilesize)
	
	# first pick exit_y cause width>height and you can pic bigger distance
	var exit_y = (randi()%(height-2))+1

	var dif_y = start_y-exit_y 
	if (dif_y<0):
		dif_y = -dif_y 
	var exit_x
	if (dif_y>=distance): # check trivial case
		exit_x = randi()%width
	else:
		var min_dif_x = distance - dif_y # dif_x + dif_y = distance
		var temp_range = width-2 # alias all cells that can be choosen
		var flag = 0 # changes flag if start is close to wall
		if(start_x<=min_dif_x):
			temp_range += -start_x - min_dif_x
			flag = 1 # start is near 0
		elif((start_x+min_dif_x)>=width):
			temp_range += -start_x - min_dif_x
			flag = 2 # start is near width
		else:
			temp_range += -(2*min_dif_x)
			
		exit_x = (randi()%temp_range)+1
		if(flag==1):
			exit_x += start_x + min_dif_x
		elif(exit_x >= (start_x-min_dif_x)):
				exit_x += (2*min_dif_x)
	
	get_node(\"tuer\").set_pos(Vector2(exit_x*tilesize,exit_y*tilesize))
	map[start_x][start_y] = 2
	map[exit_x][exit_y] = 3
	
	
	
	
	#generate $(pathes) ways between start and exit with no wall
	for i in range(pathes):
		var point = {
			\"x\" : start_x,
			\"y\" : start_y,
			}
		while( (point[\"x\"]!=exit_x) or (point[\"y\"]!=exit_y)):
				var temp = randi()%2
				
				if(((temp==0)and(point[\"x\"]!=exit_x))or((temp==1)and(point[\"y\"]==exit_y))):
					if(point[\"x\"]<exit_x):
						point[\"x\"]+=1
					else: 
						point[\"x\"]-=1
				else:
					if(point[\"y\"]<exit_y):
						point[\"y\"]+=1
					else:
						point[\"y\"]-=1
						
				if((point[\"x\"]!=exit_x)or(point[\"y\"]!=exit_y)):
					map[point[\"x\"]][point[\"y\"]] = 0
	
	for i in range(width):
		for j in range(height):
			set_cell(i,j,map[i][j])
	#connect(\"ready\",get_parent(),\"set_start\")
	emit_signal(\"ready\")





func get_start():
	return start"

[sub_resource type="CapsuleShape2D" id=2]

custom_solver_bias = 0.0
radius = 10.0
height = 20.0

[node name="TileMap" type="TileMap" groups=[
"wall",
]]

mode = 0
tile_set = ExtResource( 1 )
cell/size = Vector2( 32, 32 )
cell/quadrant_size = 40
cell/custom_transform = Matrix32( 1, 0, 0, 1, 0, 0 )
cell/half_offset = 2
cell/tile_origin = 0
cell/y_sort = false
collision/use_kinematic = false
collision/friction = 1.0
collision/bounce = 0.0
collision/layers = 1
collision/mask = 1
occluder/light_mask = 1
tile_data = IntArray(  )
script/script = SubResource( 1 )
distance = 15
width = 40
height = 30
tilesize = 32
pathes = 5
wall_x = 25
wall_y = 33
wall_x_max_len = 13
wall_y_max_len = 10
start = null

[node name="tuer" type="Sprite" parent="."]

texture = ExtResource( 2 )
centered = false

[node name="Area2D" type="Area2D" parent="tuer"]

input/pickable = true
shapes/0/shape = SubResource( 2 )
shapes/0/transform = Matrix32( 1.39037, 0, 0, 0.832393, 13.739, 15.5618 )
shapes/0/trigger = false
gravity_vec = Vector2( 0, 1 )
gravity = 98.0
linear_damp = 0.1
angular_damp = 1.0

[node name="CollisionShape2D" type="CollisionShape2D" parent="tuer/Area2D"]

transform/pos = Vector2( 13.739, 15.5618 )
transform/scale = Vector2( 1.39037, 0.832393 )
shape = SubResource( 2 )
trigger = false
_update_shape_index = 0


