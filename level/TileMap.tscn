[gd_scene load_steps=3 format=1]

[ext_resource path="res://level/TileSet.tres" type="TileSet" id=1]

[sub_resource type="GDScript" id=1]

script/source = "extends TileMap

var distance = 15
var width = 40
var height = 30
var pathes = 5 #pathes without obstacles
var wall_x = int(height/1.2) #walls oriated parallel to x-axis
var wall_y = int(width/1.2) #walls oriated parallel to y-axis
var wall_x_max_len = int(width/3)
var wall_y_max_len = int(height/3)

func _ready():
	# Called every time the node is added to the scene.
	# Initialization here
	
	
	
	var map = {}

	# init map with all tiles 0
	for i in range(width):
		map[i] = {}
		for j in range(height):
			map[i][j] = 0
	
	
	
	
	# place $(wall_x) walls parallel to x-axis
	var walls = []
	for i in range(wall_x):
		#random y position of wall
		var temp = randi()%(height-walls.size())
		while(walls.has(temp)):
			temp += 1
		walls.append(temp)
		
		var len = randi()%wall_x_max_len #random lenght of wall
		var offset = randi()%(width-len) #space between side and wall
		for j in range(len):
			map[j+offset][temp] = 1

	# place $(wall_y) walls parallel to y-axis
	walls = []
	for i in range(wall_y):
		#random x position of wall
		var temp = randi()%(width-walls.size())
		while(walls.has(temp)):
			temp += 1
		walls.append(temp)
		
		var len = randi()%wall_y_max_len #random lenght of wall
		var offset = randi()%(height-len) # space between top and wall
		for j in range(len):
			map[temp][j+offset] = 1
	
	
	
	
	# random Start and Exit points at least distance tiles away from each other
	randomize() #new randomseed
	# start
	var start_x = randi()%width
	var start_y = randi()%height
	
	# first pick exit_y cause width>height and you can pic bigger distance
	var exit_y = randi()%height

	var dif_y = start_y-exit_y 
	if (dif_y<0):
		dif_y = -dif_y 
	var exit_x
	if (dif_y>=distance): # check trivial case
		exit_x = randi()%width
	else:
		var min_dif_x = distance - dif_y # dif_x + dif_y = distance
		var temp_range # alias all cells that can be choosen
		var flag = 0 # changes flag if start is close to wall
		if(start_x<=min_dif_x):
			temp_range = width - start_x - min_dif_x
			flag = 1 # start is near 0
		elif((start_x+min_dif_x)>=width):
			temp_range = width - start_x - min_dif_x
			flag = 2 # start is near width
		else:
			temp_range = width - (2*min_dif_x)
			
		exit_x = randi()%temp_range
		if(flag==1):
			exit_x += start_x + min_dif_x
		elif(exit_x >= (start_x-min_dif_x)):
				exit_x += (2*min_dif_x)
	
	map[start_x][start_y] = 2
	map[exit_x][exit_y] = 3
	
	
	
	
	#generate $(pathes) ways between start and exit with no wall
	for i in range(pathes):
		var point = {
			\"x\" : start_x,
			\"y\" : start_y,
			}
		while( (point[\"x\"]!=exit_x) or (point[\"y\"]!=exit_y)):
				var temp = randi()%2
				
				if(((temp==0)and(point[\"x\"]!=exit_x))or((temp==1)and(point[\"y\"]==exit_y))):
					if(point[\"x\"]<exit_x):
						point[\"x\"]+=1
					else: 
						point[\"x\"]-=1
				else:
					if(point[\"y\"]<exit_y):
						point[\"y\"]+=1
					else:
						point[\"y\"]-=1
						
				if((point[\"x\"]!=exit_x)or(point[\"y\"]!=exit_y)):
					map[point[\"x\"]][point[\"y\"]] = 0
	
	for i in range(width):
		for j in range(height):
			set_cell(i,j,map[i][j])
	
	
	pass
"

[node name="TileMap" type="TileMap"]

mode = 0
tile_set = ExtResource( 1 )
cell/size = Vector2( 32, 32 )
cell/quadrant_size = 40
cell/custom_transform = Matrix32( 1, 0, 0, 1, 0, 0 )
cell/half_offset = 2
cell/tile_origin = 0
cell/y_sort = false
collision/use_kinematic = false
collision/friction = 1.0
collision/bounce = 0.0
collision/layers = 1
collision/mask = 1
occluder/light_mask = 1
tile_data = IntArray(  )
script/script = SubResource( 1 )


